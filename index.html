<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QRã‚³ãƒ¼ãƒ‰ä½œæˆãƒ»èª­ã¿å–ã‚Šãƒ„ãƒ¼ãƒ«</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #8B0000 0%, #4A0000 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #8B0000 0%, #B22222 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
        }

        .tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            border: none;
            background: transparent;
            font-size: 16px;
            color: #8B0000;
        }

        .tab:hover {
            background: #e8e8e8;
        }

        .tab.active {
            background: white;
            color: #8B0000;
            border-bottom: 3px solid #8B0000;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .input-group input[type="text"],
        .input-group textarea,
        .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
            color: #8B0000;
            font-weight: 500;
        }

        .input-group select option {
            color: #8B0000;
        }

        .input-group input:focus,
        .input-group textarea:focus,
        .input-group select:focus {
            outline: none;
            border-color: #8B0000;
        }

        .input-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #8B0000 0%, #B22222 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(139, 0, 0, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #CD5C5C 0%, #DC143C 100%);
        }

        #qrcode {
            display: flex;
            justify-content: center;
            margin: 30px 0;
            min-height: 256px;
        }

        #qrcode canvas,
        #qrcode img {
            max-width: 100%;
            height: auto;
        }

        .qr-actions {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }

        .split-preview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .split-item {
            text-align: center;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 10px;
            border: 2px solid #ddd;
        }

        .split-item canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin: 10px 0;
        }

        .file-input-wrapper {
            display: inline-block;
            margin: 10px 5px;
        }

        .upload-area {
            border: 3px dashed #8B0000;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background: #fff5f5;
            transition: all 0.3s;
        }

        .upload-area:hover {
            background: #ffe5e5;
            border-color: #B22222;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .preview-item {
            position: relative;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            background: white;
        }

        .preview-item img {
            max-width: 100%;
            border-radius: 5px;
        }

        .preview-item .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #f5576c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 18px;
            line-height: 25px;
            padding: 0;
        }

        .result-box {
            background: #fff5f5;
            border: 2px solid #8B0000;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            word-break: break-all;
        }

        .result-box h3 {
            color: #8B0000;
            margin-bottom: 10px;
        }

        .hidden {
            display: none;
        }

        canvas {
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”² QRã‚³ãƒ¼ãƒ‰ä½œæˆãƒ»èª­ã¿å–ã‚Šãƒ„ãƒ¼ãƒ«</h1>
            <p>QRã‚³ãƒ¼ãƒ‰ã®ä½œæˆã€åˆ†å‰²ã€èª­ã¿å–ã‚ŠãŒã§ãã¾ã™</p>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('create')">QRã‚³ãƒ¼ãƒ‰ä½œæˆ</button>
            <button class="tab" onclick="switchTab('read')">QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Š</button>
        </div>

        <!-- QRã‚³ãƒ¼ãƒ‰ä½œæˆã‚¿ãƒ– -->
        <div id="create-tab" class="tab-content active">
            <div class="input-group">
                <label for="qr-text">ãƒ†ã‚­ã‚¹ãƒˆ / URL:</label>
                <textarea id="qr-text" placeholder="QRã‚³ãƒ¼ãƒ‰ã«ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚„URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"></textarea>
            </div>

            <div class="input-group">
                <label for="split-count">åˆ†å‰²æ•°:</label>
                <select id="split-count">
                    <option value="1">åˆ†å‰²ã—ãªã„</option>
                    <option value="2">2åˆ†å‰²</option>
                    <option value="3">3åˆ†å‰²</option>
                    <option value="4">4åˆ†å‰²</option>
                    <option value="5">5åˆ†å‰²</option>
                </select>
            </div>

            <button class="btn" onclick="generateQR()">QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ</button>

            <div id="qrcode"></div>

            <div id="qr-actions" class="qr-actions hidden">
                <button class="btn" onclick="downloadQR()">å®Œå…¨ç‰ˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                <button class="btn btn-secondary" onclick="downloadSplitQRs()">åˆ†å‰²ç‰ˆã‚’ZIPã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>

            <div id="split-preview" class="split-preview"></div>
        </div>

        <!-- QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šã‚¿ãƒ– -->
        <div id="read-tab" class="tab-content">
            <div class="upload-area" id="drop-area">
                <p style="font-size: 1.2em; margin-bottom: 15px;">ğŸ“ QRã‚³ãƒ¼ãƒ‰ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</p>
                <p style="color: #666; margin-bottom: 20px;">ã¾ãŸã¯</p>
                <div class="file-input-wrapper">
                    <label class="btn" style="cursor: pointer;">
                        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
                        <input type="file" id="qr-upload" accept="image/*" multiple onchange="handleFiles(this.files)" style="display: none;">
                    </label>
                </div>
                <p style="color: #666; margin-top: 15px; font-size: 0.9em;">è¤‡æ•°ã®QRã‚³ãƒ¼ãƒ‰ã‚’é¸æŠã™ã‚‹ã¨é‡ã­ã¦èª­ã¿å–ã‚Šã¾ã™</p>
            </div>

            <div id="preview-grid" class="preview-grid"></div>

            <div style="text-align: center; margin: 20px 0;">
                <button class="btn" onclick="readQRCodes()" id="read-btn" style="display: none;">QRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚‹</button>
                <button class="btn btn-secondary" onclick="clearReader()" id="clear-btn" style="display: none;">ã‚¯ãƒªã‚¢</button>
            </div>

            <div id="result" class="result-box hidden">
                <h3>èª­ã¿å–ã‚Šçµæœ:</h3>
                <p id="result-text"></p>
            </div>
        </div>
    </div>

    <script>
        let currentQRCanvas = null;
        let uploadedImages = [];

        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tab + '-tab').classList.add('active');
        }

        function generateQR() {
            const text = document.getElementById('qr-text').value.trim();
            const splitCount = parseInt(document.getElementById('split-count').value);

            if (!text) {
                alert('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            const qrcodeDiv = document.getElementById('qrcode');
            qrcodeDiv.innerHTML = '';

            const size = 512;
            const qr = new QRCode(qrcodeDiv, {
                text: text,
                width: size,
                height: size,
                correctLevel: QRCode.CorrectLevel.H
            });

            setTimeout(() => {
                currentQRCanvas = qrcodeDiv.querySelector('canvas');
                document.getElementById('qr-actions').classList.remove('hidden');
                
                if (splitCount > 1) {
                    generateSplitQRs(splitCount);
                } else {
                    document.getElementById('split-preview').innerHTML = '';
                }
            }, 100);
        }

        function generateSplitQRs(count) {
            if (!currentQRCanvas) return;

            const canvas = currentQRCanvas;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // QRã‚³ãƒ¼ãƒ‰ã®å®Ÿéš›ã®é ˜åŸŸã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹é€ ã‚’æ­£ç¢ºã«æ¤œå‡º
            const qrInfo = detectQRStructurePrecise(canvas);
            const moduleSize = qrInfo.moduleSize;
            const modules = qrInfo.modules;
            const offsetX = qrInfo.offsetX;
            const offsetY = qrInfo.offsetY;
            const qrWidth = qrInfo.qrWidth;
            const qrHeight = qrInfo.qrHeight;
            
            console.log(`æ¤œå‡º: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚µã‚¤ã‚º=${moduleSize}px, ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ•°=${modules}x${modules}, QRã‚µã‚¤ã‚º=${qrWidth}x${qrHeight}, ã‚ªãƒ•ã‚»ãƒƒãƒˆ=(${offsetX}, ${offsetY})`);
            
            const splitPreview = document.getElementById('split-preview');
            splitPreview.innerHTML = '';

            const splits = [];
            
            // ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å˜ä½ï¼ˆ1ãƒ”ã‚¯ã‚»ãƒ«=1ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰ã§QRã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º
            const moduleCanvas = document.createElement('canvas');
            moduleCanvas.width = modules;
            moduleCanvas.height = modules;
            const moduleCtx = moduleCanvas.getContext('2d');
            const moduleImageData = moduleCtx.createImageData(modules, modules);
            
            // å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è‰²ã‚’åˆ¤å®šã—ã¦1x1ãƒ”ã‚¯ã‚»ãƒ«ã«å¤‰æ›
            for (let moduleY = 0; moduleY < modules; moduleY++) {
                for (let moduleX = 0; moduleX < modules; moduleX++) {
                    // ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸­å¿ƒãƒ”ã‚¯ã‚»ãƒ«ã®è‰²ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                    const centerX = Math.floor(offsetX + (moduleX + 0.5) * moduleSize);
                    const centerY = Math.floor(offsetY + (moduleY + 0.5) * moduleSize);
                    const pixelIdx = (centerY * canvas.width + centerX) * 4;
                    
                    const brightness = (data[pixelIdx] + data[pixelIdx + 1] + data[pixelIdx + 2]) / 3;
                    const color = brightness < 128 ? 0 : 255;
                    
                    const moduleIdx = (moduleY * modules + moduleX) * 4;
                    moduleImageData.data[moduleIdx] = color;
                    moduleImageData.data[moduleIdx + 1] = color;
                    moduleImageData.data[moduleIdx + 2] = color;
                    moduleImageData.data[moduleIdx + 3] = 255;
                }
            }
            
            moduleCtx.putImageData(moduleImageData, 0, 0);
            
            // ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ã§ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†å‰²å…ˆã‚’å‰²ã‚Šå½“ã¦
            const assignments = new Uint8Array(modules * modules);
            for (let i = 0; i < assignments.length; i++) {
                assignments[i] = Math.floor(Math.random() * count);
            }

            // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå·¦ä¸Šã€å³ä¸Šã€å·¦ä¸‹ï¼‰ã®7x7ãƒ”ã‚¯ã‚»ãƒ«ã‚’å…¨åˆ†å‰²ã«å«ã‚ã‚‹
            const markerSize = 7;
            const preserveAreas = [
                {x: 0, y: 0, w: markerSize, h: markerSize}, // å·¦ä¸Š
                {x: modules - markerSize, y: 0, w: markerSize, h: markerSize}, // å³ä¸Š
                {x: 0, y: modules - markerSize, w: markerSize, h: markerSize} // å·¦ä¸‹
            ];

            for (let splitIndex = 0; splitIndex < count; splitIndex++) {
                // å°ã•ã„ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆ1ãƒ”ã‚¯ã‚»ãƒ«=1ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰ã§åˆ†å‰²
                const smallCanvas = document.createElement('canvas');
                smallCanvas.width = modules;
                smallCanvas.height = modules;
                const smallCtx = smallCanvas.getContext('2d');
                const smallImageData = smallCtx.createImageData(modules, modules);

                // èƒŒæ™¯ã‚’ç™½ã«
                for (let i = 0; i < smallImageData.data.length; i += 4) {
                    smallImageData.data[i] = 255;
                    smallImageData.data[i + 1] = 255;
                    smallImageData.data[i + 2] = 255;
                    smallImageData.data[i + 3] = 255;
                }

                // ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ã§ã‚³ãƒ”ãƒ¼
                for (let y = 0; y < modules; y++) {
                    for (let x = 0; x < modules; x++) {
                        const pixelIdx = y * modules + x;
                        let shouldInclude = assignments[pixelIdx] === splitIndex;
                        
                        // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆ7x7ãƒ”ã‚¯ã‚»ãƒ«ï¼‰ã¯å…¨åˆ†å‰²ã«å«ã‚ã‚‹
                        for (const area of preserveAreas) {
                            if (x >= area.x && x < area.x + area.w && 
                                y >= area.y && y < area.y + area.h) {
                                shouldInclude = true;
                                break;
                            }
                        }

                        if (shouldInclude) {
                            const srcIdx = pixelIdx * 4;
                            const dstIdx = srcIdx;
                            smallImageData.data[dstIdx] = moduleImageData.data[srcIdx];
                            smallImageData.data[dstIdx + 1] = moduleImageData.data[srcIdx + 1];
                            smallImageData.data[dstIdx + 2] = moduleImageData.data[srcIdx + 2];
                            smallImageData.data[dstIdx + 3] = moduleImageData.data[srcIdx + 3];
                        }
                    }
                }

                smallCtx.putImageData(smallImageData, 0, 0);
                
                // ã‚¹ãƒ†ãƒƒãƒ—3: å…ƒã®QRã‚³ãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºã«æ­£ç¢ºã«æ‹¡å¤§
                const splitCanvas = document.createElement('canvas');
                splitCanvas.width = canvas.width;
                splitCanvas.height = canvas.height;
                const splitCtx = splitCanvas.getContext('2d');
                
                // ç™½ã§å¡—ã‚Šã¤ã¶ã—
                splitCtx.fillStyle = '#FFFFFF';
                splitCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ãƒ”ã‚¯ã‚»ãƒ«ã‚’æ»‘ã‚‰ã‹ã«ã—ãªã„ï¼ˆã‚·ãƒ£ãƒ¼ãƒ—ãªæ‹¡å¤§ï¼‰
                splitCtx.imageSmoothingEnabled = false;
                
                // å°ã•ã„ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆmodules x modulesï¼‰ã‚’å…ƒã®QRã‚³ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºï¼ˆqrWidth x qrHeightï¼‰ã«æ‹¡å¤§
                splitCtx.drawImage(smallCanvas, 0, 0, modules, modules, 
                                  offsetX, offsetY, qrWidth, qrHeight);
                
                splits.push(splitCanvas);

                const splitItem = document.createElement('div');
                splitItem.className = 'split-item';
                splitItem.innerHTML = `
                    <h4>åˆ†å‰² ${splitIndex + 1}/${count}</h4>
                    <canvas width="${canvas.width}" height="${canvas.height}"></canvas>
                `;
                const displayCanvas = splitItem.querySelector('canvas');
                const displayCtx = displayCanvas.getContext('2d');
                displayCtx.imageSmoothingEnabled = false;
                displayCtx.drawImage(splitCanvas, 0, 0);
                splitPreview.appendChild(splitItem);
            }

            window.splitCanvases = splits;
        }

        function detectQRStructurePrecise(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // QRã‚³ãƒ¼ãƒ‰ã®å®Ÿéš›ã®é–‹å§‹ä½ç½®ã‚’æ¤œå‡ºï¼ˆé™ç©ã‚¾ãƒ¼ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰
            let topStart = -1;
            let bottomEnd = -1;
            let leftStart = -1;
            let rightEnd = -1;
            
            // ä¸Šç«¯ã‚’æ¤œå‡º
            for (let y = 0; y < canvas.height && topStart === -1; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx] < 200) { // é»’ã¾ãŸã¯æ¿ƒã„ã‚°ãƒ¬ãƒ¼
                        topStart = y;
                        break;
                    }
                }
            }
            
            // ä¸‹ç«¯ã‚’æ¤œå‡º
            for (let y = canvas.height - 1; y >= 0 && bottomEnd === -1; y--) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx] < 200) {
                        bottomEnd = y + 1;
                        break;
                    }
                }
            }
            
            // å·¦ç«¯ã‚’æ¤œå‡º
            for (let x = 0; x < canvas.width && leftStart === -1; x++) {
                for (let y = 0; y < canvas.height; y++) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx] < 200) {
                        leftStart = x;
                        break;
                    }
                }
            }
            
            // å³ç«¯ã‚’æ¤œå‡º
            for (let x = canvas.width - 1; x >= 0 && rightEnd === -1; x--) {
                for (let y = 0; y < canvas.height; y++) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx] < 200) {
                        rightEnd = x + 1;
                        break;
                    }
                }
            }
            
            const qrWidth = rightEnd - leftStart;
            const qrHeight = bottomEnd - topStart;
            
            console.log(`QRé ˜åŸŸ: left=${leftStart}, top=${topStart}, width=${qrWidth}, height=${qrHeight}`);
            
            // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è§£æã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ•°ã‚’æ­£ç¢ºã«æ¤œå‡º
            const modules = detectModuleCountFromPattern(data, canvas.width, leftStart, topStart, qrWidth);
            
            console.log(`æ¤œå‡ºã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ•°: ${modules}`);
            
            return {
                moduleSize: qrWidth / modules,
                modules: modules,
                offsetX: leftStart,
                offsetY: topStart,
                qrWidth: qrWidth,
                qrHeight: qrHeight
            };
        }

        function detectModuleCountFromPattern(data, canvasWidth, leftStart, topStart, qrWidth) {
            // å·¦ä¸Šã®ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸Šè¾ºã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã€é»’ç™½ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
            // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã¯: é»’7ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« ã®å¤–æ 
            
            const scanY = topStart + 3; // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸­å¤®ä»˜è¿‘ã®è¡Œ
            let segments = [];
            let currentColor = -1;
            let segmentStart = leftStart;
            
            // è‰²ã®å¤‰åŒ–ã‚’æ¤œå‡º
            for (let x = leftStart; x < leftStart + Math.min(qrWidth / 2, 300); x++) {
                const idx = (scanY * canvasWidth + x) * 4;
                const brightness = data[idx];
                const isBlack = brightness < 128;
                const color = isBlack ? 0 : 1;
                
                if (currentColor === -1) {
                    currentColor = color;
                    segmentStart = x;
                } else if (color !== currentColor) {
                    segments.push({
                        start: segmentStart,
                        end: x,
                        width: x - segmentStart,
                        color: currentColor
                    });
                    currentColor = color;
                    segmentStart = x;
                }
            }
            
            // æœ€åˆã®é»’é ˜åŸŸãŒä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¤–æ ï¼ˆ7ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¹…ï¼‰ã®ã¯ãš
            let moduleSize = 1;
            if (segments.length > 0 && segments[0].color === 0) {
                moduleSize = segments[0].width / 7;
                console.log(`ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰è¨ˆç®—: å¹…=${segments[0].width}px, ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚µã‚¤ã‚º=${moduleSize}px`);
            } else {
                // ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯æ¨å®š
                console.log('ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æ¨å®šã—ã¾ã™ã€‚');
                moduleSize = qrWidth / 21; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            }
            
            // QRã‚³ãƒ¼ãƒ‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ•°ã‚’è¨ˆç®—
            // ãƒãƒ¼ã‚¸ãƒ§ãƒ³1: 21, ãƒãƒ¼ã‚¸ãƒ§ãƒ³2: 25, ... ãƒãƒ¼ã‚¸ãƒ§ãƒ³n: 21 + (n-1)*4
            const possibleModules = [];
            for (let version = 1; version <= 40; version++) {
                possibleModules.push(21 + (version - 1) * 4);
            }
            
            // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚µã‚¤ã‚ºã‹ã‚‰æœ€ã‚‚è¿‘ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ•°ã‚’é¸æŠ
            let bestModules = 21;
            let minError = Infinity;
            
            for (const m of possibleModules) {
                const estimatedWidth = m * moduleSize;
                const error = Math.abs(qrWidth - estimatedWidth);
                if (error < minError) {
                    minError = error;
                    bestModules = m;
                }
            }
            
            console.log(`æœ€é©ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ•°: ${bestModules}, èª¤å·®: ${minError}px`);
            
            return bestModules;
        }

        function downloadQR() {
            if (!currentQRCanvas) return;
            
            const link = document.createElement('a');
            link.download = 'qrcode.png';
            link.href = currentQRCanvas.toDataURL();
            link.click();
        }

        async function downloadSplitQRs() {
            const splitCount = parseInt(document.getElementById('split-count').value);
            
            if (splitCount === 1) {
                downloadQR();
                return;
            }

            if (!window.splitCanvases || window.splitCanvases.length === 0) {
                alert('åˆ†å‰²QRã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
            const zip = new JSZip();
            
            for (let index = 0; index < window.splitCanvases.length; index++) {
                const canvas = window.splitCanvases[index];
                const dataUrl = canvas.toDataURL('image/png');
                const base64Data = dataUrl.split(',')[1];
                zip.file(`qrcode_split_${index + 1}_of_${splitCount}.png`, base64Data, {base64: true});
            }
            
            // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blob = await zip.generateAsync({type: 'blob'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'qrcode_split.zip';
            link.click();
            URL.revokeObjectURL(link.href);
        }

        // QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šæ©Ÿèƒ½
        const dropArea = document.getElementById('drop-area');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => {
                dropArea.style.borderColor = '#B22222';
                dropArea.style.background = '#ffe5e5';
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => {
                dropArea.style.borderColor = '#8B0000';
                dropArea.style.background = '#fff5f5';
            });
        });

        dropArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        });

        function handleFiles(files) {
            uploadedImages = [];
            const previewGrid = document.getElementById('preview-grid');
            previewGrid.innerHTML = '';

            let loadedCount = 0;
            const totalFiles = Array.from(files).filter(f => f.type.startsWith('image/')).length;
            
            if (totalFiles === 0) {
                alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            Array.from(files).forEach((file, index) => {
                if (!file.type.startsWith('image/')) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImages.push(img);
                        loadedCount++;
                        
                        const previewItem = document.createElement('div');
                        previewItem.className = 'preview-item';
                        previewItem.innerHTML = `
                            <img src="${e.target.result}" alt="QR ${uploadedImages.length}">
                            <button class="remove-btn" onclick="removeImage(${uploadedImages.length - 1})">Ã—</button>
                            <p style="margin-top: 5px; font-size: 0.9em;">QR ${uploadedImages.length}</p>
                        `;
                        previewGrid.appendChild(previewItem);
                        
                        // ã™ã¹ã¦ã®ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                        if (loadedCount === totalFiles) {
                            document.getElementById('read-btn').style.display = 'inline-block';
                            document.getElementById('clear-btn').style.display = 'inline-block';
                        }
                    };
                    img.onerror = () => {
                        console.error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', file.name);
                        loadedCount++;
                        if (loadedCount === totalFiles && uploadedImages.length > 0) {
                            document.getElementById('read-btn').style.display = 'inline-block';
                            document.getElementById('clear-btn').style.display = 'inline-block';
                        }
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', file.name);
                };
                reader.readAsDataURL(file);
            });

            document.getElementById('result').classList.add('hidden');
        }

        function removeImage(index) {
            console.log('removeImage called with index:', index);
            uploadedImages.splice(index, 1);
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚°ãƒªãƒƒãƒ‰ã‚’å†æ§‹ç¯‰
            const previewGrid = document.getElementById('preview-grid');
            previewGrid.innerHTML = '';
            
            uploadedImages.forEach((img, i) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';
                previewItem.innerHTML = `
                    <img src="${img.src}" alt="QR ${i + 1}">
                    <button class="remove-btn" onclick="removeImage(${i})">Ã—</button>
                    <p style="margin-top: 5px; font-size: 0.9em;">QR ${i + 1}</p>
                `;
                previewGrid.appendChild(previewItem);
            });
            
            if (uploadedImages.length === 0) {
                document.getElementById('read-btn').style.display = 'none';
                document.getElementById('clear-btn').style.display = 'none';
            }
        }

        function readQRCodes() {
            console.log('readQRCodes called, uploadedImages.length:', uploadedImages.length);
            
            if (uploadedImages.length === 0) {
                alert('QRã‚³ãƒ¼ãƒ‰ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„');
                return;
            }

            try {
                if (uploadedImages.length === 1) {
                    // å˜ä¸€QRã‚³ãƒ¼ãƒ‰ã®èª­ã¿å–ã‚Š
                    console.log('å˜ä¸€QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šé–‹å§‹');
                    readSingleQR(uploadedImages[0]);
                } else {
                    // è¤‡æ•°QRã‚³ãƒ¼ãƒ‰ã‚’é‡ã­ã¦èª­ã¿å–ã‚Š
                    console.log('è¤‡æ•°QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šé–‹å§‹');
                    mergeAndReadQRs(uploadedImages);
                }
            } catch (error) {
                console.error('QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼:', error);
                showResult('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        function readSingleQR(img) {
            console.log('readSingleQR: ç”»åƒã‚µã‚¤ã‚º', img.width, 'x', img.height);
            
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            console.log('imageDataå–å¾—å®Œäº†:', imageData.width, 'x', imageData.height);
            
            if (typeof jsQR === 'undefined') {
                showResult('ã‚¨ãƒ©ãƒ¼: jsQRãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const code = jsQR(imageData.data, imageData.width, imageData.height);
            console.log('jsQRçµæœ:', code);

            if (code) {
                console.log('QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚ŠæˆåŠŸ:', code.data);
                showResult(code.data);
            } else {
                console.log('QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šå¤±æ•—');
                showResult('QRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ç”»åƒãŒé®®æ˜ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            }
        }

        function mergeAndReadQRs(images) {
            console.log('mergeAndReadQRs: ç”»åƒæ•°', images.length);
            
            const canvas = document.createElement('canvas');
            canvas.width = images[0].width;
            canvas.height = images[0].height;
            const ctx = canvas.getContext('2d');

            // æœ€åˆã®ç”»åƒã§åˆæœŸåŒ–
            ctx.drawImage(images[0], 0, 0);
            const mergedData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // ä»–ã®ç”»åƒã‚’é‡ã­ã‚‹ï¼ˆé»’ãƒ”ã‚¯ã‚»ãƒ«ã‚’å„ªå…ˆï¼‰
            for (let i = 1; i < images.length; i++) {
                console.log(`ç”»åƒ ${i + 1} ã‚’é‡ã­åˆã‚ã›ä¸­...`);
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(images[i], 0, 0);
                const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);

                for (let j = 0; j < mergedData.data.length; j += 4) {
                    const r1 = mergedData.data[j];
                    const r2 = tempData.data[j];
                    
                    // ã‚ˆã‚Šæš—ã„ãƒ”ã‚¯ã‚»ãƒ«ã‚’æ¡ç”¨
                    if (r2 < r1) {
                        mergedData.data[j] = r2;
                        mergedData.data[j + 1] = tempData.data[j + 1];
                        mergedData.data[j + 2] = tempData.data[j + 2];
                    }
                }
            }

            ctx.putImageData(mergedData, 0, 0);
            console.log('ç”»åƒã®çµåˆå®Œäº†');
            
            if (typeof jsQR === 'undefined') {
                showResult('ã‚¨ãƒ©ãƒ¼: jsQRãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const code = jsQR(mergedData.data, mergedData.width, mergedData.height);
            console.log('jsQRçµæœ:', code);

            if (code) {
                console.log('çµåˆQRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚ŠæˆåŠŸ:', code.data);
                showResult(code.data);
            } else {
                console.log('çµåˆQRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šå¤±æ•—');
                showResult('çµåˆã—ãŸQRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚å…¨ã¦ã®åˆ†å‰²ç”»åƒãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            }
        }

        function showResult(text) {
            console.log('showResult:', text);
            document.getElementById('result').classList.remove('hidden');
            document.getElementById('result-text').textContent = text;
        }

        function clearReader() {
            uploadedImages = [];
            document.getElementById('preview-grid').innerHTML = '';
            document.getElementById('read-btn').style.display = 'none';
            document.getElementById('clear-btn').style.display = 'none';
            document.getElementById('result').classList.add('hidden');
            document.getElementById('qr-upload').value = '';
        }
    </script>
</body>
</html>
